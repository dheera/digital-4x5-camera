#!/usr/bin/env python3

import atexit
import json
import numpy as np
import os
import sys
import time
from camera.calibrated_stepper import CalibratedStepper
from camera.config import config
from camera.helpers import *

import picamerax
import picamerax.array

DRY_RUN = "--dry-run" in sys.argv
NO_PREVIEW = "--no-preview" in sys.argv

class PictureScan(object):
    def __init__(self, profile, config, settings):
        self.profile = profile
        self.config = config
        self.settings = settings

        self.steppers = [
            CalibratedStepper(0, power = 127),
            CalibratedStepper(1, power = 127),
        ]

        self.sensor_tiles = np.array(profile["dimensions"]) / np.array(config["sensor"]["sensor_size"])

        self.total_steps = (np.array(profile["dimensions"]) / np.array([
            config["axes"][0]["distance_per_step"],
            config["axes"][1]["distance_per_step"],
        ])).astype(np.int32)

        self.tile_size_steps = np.array(config["sensor"]["sensor_size"]) / np.array([
            config["axes"][0]["distance_per_step"],
            config["axes"][1]["distance_per_step"],
        ])

        self.adjusted_increment_steps = (self.tile_size_steps * (1 - np.array(profile["overlap"]))).astype(np.int32)

        self.num_tiles = np.ceil(self.total_steps / self.adjusted_increment_steps).astype(np.int32)

        self.center_steps = (np.array([config["axes"][0]["steps"], config["axes"][1]["steps"]]) / 2).astype(np.int32)

        print("sensor_tiles:", self.sensor_tiles)
        print("total_steps:", self.total_steps)
        print("tile_size_steps:", self.tile_size_steps)
        print("adjusted_increment_steps:", self.adjusted_increment_steps)
        print("num_tiles:", self.num_tiles)
        print("center_steps:", self.center_steps)

        self.picam = picamerax.PiCamera()

        self.fnstem = "%s-%s" % (random_word(), random_word())

        if not DRY_RUN:
            os.system("mkdir -p output/%s" % self.fnstem)

        print("Setting settings ...")
        self.picam.framerate = 1e6 / self.settings.get("shutter_speed", 32000)
        self.picam.awb_mode = "off"
        self.picam.awb_gains = self.settings.get("awb_gains", [1, -1])
        self.picam.iso = self.settings.get("iso", 100)
        self.picam.shutter_speed = self.settings.get("shutter_speed", 32000)
        time.sleep(2)
        self.picam.exposure_mode = self.settings.get("exposure_mode", "off")
        print("shutter_speed", self.picam.shutter_speed, self.picam.exposure_speed)
        print("iso", self.picam.iso)
        print("awb_gains", self.picam.awb_gains)
        print("gains", self.picam.analog_gain, self.picam.digital_gain)
        print("done")

    def acquire(self):
        print("Beginning acquisition")

        if not NO_PREVIEW:
            self.picam.start_preview()

        time.sleep(2)

        print("total_tiles_to_acquire: %d" % (self.num_tiles[1] * self.num_tiles[0]))

        yrange_enumerated = list(enumerate(np.arange(-self.num_tiles[1] / 2 + 0.5, self.num_tiles[1] / 2 + 0.5)))
        xrange_enumerated_even = list(enumerate(np.arange(-self.num_tiles[0] / 2 + 0.5, self.num_tiles[0] / 2 + 0.5)))
        xrange_enumerated_odd = list(reversed(list(enumerate(np.arange(-self.num_tiles[0] / 2 + 0.5, self.num_tiles[0] / 2 + 0.5)))))

        irritator = self.picam.capture_continuous('image{counter:03d}.jpg', format = "jpeg", bayer = True)

        for iyn, yn in yrange_enumerated:
            ytile = (yn * self.adjusted_increment_steps[1]).astype(np.int32)
            if iyn % 2 == 1:
                xrange_enumerated = xrange_enumerated_odd
            else:
                xrange_enumerated = xrange_enumerated_even
            print(iyn, yn, xrange_enumerated)
            for ixn, xn in xrange_enumerated:
                xtile = (xn * self.adjusted_increment_steps[0]).astype(np.int32)
                target_coords = np.array([xtile, ytile], dtype = np.int32) + self.center_steps
                print("Moving to tile (%f, %f) step (%d, %d)" % (xn, yn, target_coords[0], target_coords[1]))
                if not DRY_RUN:
                    self.steppers[0].goto(int(target_coords[0]))
                    self.steppers[1].goto(int(target_coords[1]))
                    filename = next(irritator)
                    os.rename(filename, os.path.join("output", self.fnstem, "img_%d_%d.jpg" % (ixn, iyn)))

        if not DRY_RUN:
            with open(os.path.join("output/%s" % self.fnstem, "profile.json"), "w") as f:
                f.write(json.dumps(self.profile))

    def start(self):
        self.acquire()
        return

if __name__ == "__main__":
    with open(sys.argv[1], "r") as f:
        profile = json.loads(f.read())
    with open("settings.json", "r") as f:
        settings = json.loads(f.read())
    PictureScan(profile, config, settings).start()
