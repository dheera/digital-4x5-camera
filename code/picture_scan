#!/usr/bin/env python3

import atexit
import json
import numpy as np
import os
import sys
import time
from camera.calibrated_stepper import CalibratedStepper
from camera.config import config
from camera.helpers import *

import io
import picamerax
import picamerax.array

DRY_RUN = "--dry-run" in sys.argv
NO_PREVIEW = "--no-preview" in sys.argv

class PictureScan(object):
    def __init__(self, profile, config):
        self.profile = profile
        self.config = config

        self.steppers = [
            CalibratedStepper(0, power = 127),
            CalibratedStepper(1, power = 127),
        ]

        self.sensor_tiles = np.array(profile["dimensions"]) / np.array(config["sensor"]["sensor_size"])

        self.total_steps = (np.array(profile["dimensions"]) / np.array([
            config["axes"][0]["distance_per_step"],
            config["axes"][1]["distance_per_step"],
        ])).astype(np.int32)

        self.tile_size_steps = np.array(config["sensor"]["sensor_size"]) / np.array([
            config["axes"][0]["distance_per_step"],
            config["axes"][1]["distance_per_step"],
        ])

        self.adjusted_increment_steps = (self.tile_size_steps * (1 - np.array(profile["overlap"]))).astype(np.int32)

        self.num_tiles = np.ceil(self.total_steps / self.adjusted_increment_steps).astype(np.int32)

        self.center_steps = (np.array([config["axes"][0]["steps"], config["axes"][1]["steps"]]) / 2).astype(np.int32)

        print("sensor_tiles:", self.sensor_tiles)
        print("total_steps:", self.total_steps)
        print("tile_size_steps:", self.tile_size_steps)
        print("adjusted_increment_steps:", self.adjusted_increment_steps)
        print("num_tiles:", self.num_tiles)
        print("center_steps:", self.center_steps)

        self.picam = picamerax.PiCamera()

        self.fnstem = "%s-%s" % (random_word(), random_word())

        if not DRY_RUN:
            os.system("mkdir -p output/%s" % self.fnstem)

    def capture(self, name):
        print("Capturing")
        stream = io.BytesIO()
        # stream = picamerax.array.PiBayerArray(self.picam)
        self.picam.capture(stream, format = 'jpeg', bayer = True)
        with open("%s.jpg" % name, "wb") as f:
            f.write(stream.getbuffer())
        # np.save(name, stream.array)
        # output = (stream.demosaic() >> 2).astype(np.uint8)
        # print(output.shape)

    def acquire(self):
        print("Beginning acquisition")

        if not NO_PREVIEW:
            self.picam.start_preview()

        print("total_tiles_to_acquire: %d" % (self.num_tiles[1] * self.num_tiles[0]))
        time.sleep(2)

        yrange_enumerated = list(enumerate(np.arange(-self.num_tiles[1] / 2 + 0.5, self.num_tiles[1] / 2 + 0.5)))
        xrange_enumerated_even = list(enumerate(np.arange(-self.num_tiles[0] / 2 + 0.5, self.num_tiles[0] / 2 + 0.5)))
        xrange_enumerated_odd = list(reversed(list(enumerate(np.arange(-self.num_tiles[0] / 2 + 0.5, self.num_tiles[0] / 2 + 0.5)))))

        for iyn, yn in yrange_enumerated:
            ytile = (yn * self.adjusted_increment_steps[1]).astype(np.int32)
            if iyn % 2 == 1:
                xrange_enumerated = xrange_enumerated_odd
            else:
                xrange_enumerated = xrange_enumerated_even
            print(iyn, yn, xrange_enumerated)
            for ixn, xn in xrange_enumerated:
                xtile = (xn * self.adjusted_increment_steps[0]).astype(np.int32)
                target_coords = np.array([xtile, ytile], dtype = np.int32) + self.center_steps
                print("Moving to tile (%f, %f) step (%d, %d)" % (xn, yn, target_coords[0], target_coords[1]))
                if not DRY_RUN:
                    self.steppers[0].goto(int(target_coords[0]))
                    self.steppers[1].goto(int(target_coords[1]))
                    time.sleep(0.1)
                    self.capture(os.path.join("output", self.fnstem, "img_%d_%d" % (ixn, iyn)))

        if not DRY_RUN:
            with open(os.path.join("output/%s" % self.fnstem, "profile.json"), "w") as f:
                f.write(json.dumps(self.profile))

    def start(self):
        self.acquire()
        return

if __name__ == "__main__":
    with open(sys.argv[1], "r") as f:
        profile = json.loads(f.read())
    PictureScan(profile, config).start()
